import { dbNamesOf, isDbReadonly, } from '../filter/filter-consumer-bridge-to-sql-request.js';
import { isAutoIncrement } from '../remult3/RepositoryImplementation.js';
import { SqlDatabase } from './sql-database.js';
//SqlDatabase.LogToConsole = true;
export class WebSqlDataProvider {
    databaseName;
    rows;
    /** @internal */
    //@ts-ignore
    db;
    constructor(databaseName, databaseSize = 2 * 1024 * 1024) {
        this.databaseName = databaseName;
        //@ts-ignore
        this.db = window.openDatabase(databaseName, '1.0', databaseName, databaseSize);
    }
    async end() { }
    getLimitSqlSyntax(limit, offset) {
        return ' limit ' + limit + ' offset ' + offset;
    }
    async entityIsUsedForTheFirstTime(entity) {
        await this.createTable(entity);
    }
    async ensureSchema(entities) {
        for (const entity of entities) {
            await this.createTable(entity);
        }
    }
    async dropTable(entity) {
        let e = await dbNamesOf(entity);
        let sql = 'drop  table if exists ' + e.$entityName;
        if (SqlDatabase.LogToConsole)
            console.info(sql);
        await this.createCommand().execute(sql);
    }
    async createTable(entity) {
        let result = '';
        let e = await dbNamesOf(entity);
        for (const x of entity.fields) {
            if (!isDbReadonly(x, e) || isAutoIncrement(x)) {
                if (result.length != 0)
                    result += ',';
                result += '\r\n  ';
                if (isAutoIncrement(x)) {
                    if (x.key != entity.idMetadata.field.key)
                        throw 'in web sql, autoincrement is only allowed for primary key';
                    result += e.$dbNameOf(x) + ' integer primary key autoincrement';
                }
                else {
                    result += this.addColumnSqlSyntax(x, e.$dbNameOf(x));
                    if (x.key == entity.idMetadata.field.key) {
                        result += ' primary key';
                    }
                }
            }
        }
        let sql = 'create table if not exists ' + e.$entityName + ' (' + result + '\r\n)';
        if (SqlDatabase.LogToConsole)
            console.log(sql);
        await this.createCommand().execute(sql);
    }
    createCommand() {
        return new WebSqlBridgeToSQLCommand(this.db);
    }
    async transaction(action) {
        throw new Error('Method not implemented.');
    }
    addColumnSqlSyntax(x, dbName) {
        let result = dbName;
        const nullNumber = x.allowNull ? '' : ' default 0 not null';
        if (x.valueType == Date)
            result += ' integer';
        else if (x.valueType == Boolean)
            result += ' integer ' + nullNumber;
        else if (x.valueType == Number) {
            if (!x.valueConverter.fieldTypeInDb)
                result += ' real ' + nullNumber;
            else
                result += ' ' + x.valueConverter.fieldTypeInDb + ' ' + nullNumber;
        }
        else
            result += ' text' + (x.allowNull ? ' ' : " default '' not null ");
        return result;
    }
    toString() {
        return 'WebSqlDataProvider';
    }
}
class WebSqlBridgeToSQLCommand {
    source;
    //@ts-ignore
    constructor(source) {
        this.source = source;
    }
    values = [];
    addParameterAndReturnSqlToken(val) {
        return this.param(val);
    }
    param(val) {
        this.values.push(val);
        return '~' + this.values.length + '~';
    }
    execute(sql) {
        return new Promise((resolve, reject) => this.source.transaction((t) => {
            let s = sql;
            let v = [];
            var m = s.match(/~\d+~/g);
            if (m != null)
                m.forEach((mr) => {
                    s = s.replace(mr, '?');
                    v.push(this.values[Number.parseInt(mr.substring(1, mr.length - 1)) - 1]);
                });
            t.executeSql(s, v, (t1, r) => resolve(new WebSqlBridgeToSQLQueryResult(r)), (t2, err) => {
                reject(err.message);
                return false;
            });
        }));
    }
}
class WebSqlBridgeToSQLQueryResult {
    r;
    getColumnKeyInResultForIndexInSelect(index) {
        if (this.rows.length == 0)
            throw Error('No rows');
        let i = 0;
        for (let m in this.rows[0]) {
            if (i++ == index)
                return m;
        }
        throw Error('index not found');
    }
    //@ts-ignore
    constructor(r) {
        this.r = r;
        this.rows = [];
        for (let i = 0; i < r.rows.length; i++) {
            this.rows.push(r.rows.item(i));
        }
    }
    rows;
}
