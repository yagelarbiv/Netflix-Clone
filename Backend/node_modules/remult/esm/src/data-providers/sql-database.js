import { FilterConsumerBridgeToSqlRequest, dbNamesOfWithForceSqlExpression, isDbReadonly, } from '../filter/filter-consumer-bridge-to-sql-request.js';
import { Filter, customDatabaseFilterToken, } from '../filter/filter-interfaces.js';
import { remult as defaultRemult } from '../remult-proxy.js';
import { getRepository, isAutoIncrement, } from '../remult3/RepositoryImplementation.js';
import { Sort } from '../sort.js';
import { ValueConverters } from '../valueConverters.js';
import { getRepositoryInternals } from '../remult3/repository-internals.js';
import { isOfType } from '../isOfType.js';
/**
 * A DataProvider for Sql Databases
 * @example
 * const db = new SqlDatabase(new PostgresDataProvider(pgPool))
* @see [Connecting a Database](https://remult.dev/docs/quickstart#connecting-a-database)

 */
export class SqlDatabase {
    sql;
    /**
     * Gets the SQL database from the data provider.
     * @param dataProvider - The data provider.
     * @returns The SQL database.
     * @see [Direct Database Access](https://remult.dev/docs/running-sql-on-the-server)
     */
    static getDb(dataProvider) {
        const r = (dataProvider || defaultRemult.dataProvider);
        if (isOfType(r, 'createCommand'))
            return r;
        else
            throw 'the data provider is not an SqlCommandFactory';
    }
    /**
     * Creates a new SQL command.
     * @returns The SQL command.
     * @see [Direct Database Access](https://remult.dev/docs/running-sql-on-the-server)
     */
    createCommand() {
        return new LogSQLCommand(this.sql.createCommand(), SqlDatabase.LogToConsole);
    }
    /**
     * Executes a SQL command.
     * @param sql - The SQL command.
     * @returns The SQL result.
     * @see [Direct Database Access](https://remult.dev/docs/running-sql-on-the-server)
     */
    async execute(sql) {
        return await this.createCommand().execute(sql);
    }
    /**
     * Wraps an identifier with the database's identifier syntax.
     */
    wrapIdentifier = (x) => x;
    /* @internal*/
    _getSourceSql() {
        return this.sql;
    }
    async ensureSchema(entities) {
        if (this.sql.ensureSchema)
            await this.sql.ensureSchema(entities);
    }
    /**
     * Gets the entity data provider.
     * @param entity  - The entity metadata.
     * @returns The entity data provider.
     */
    getEntityDataProvider(entity) {
        if (!this.sql.supportsJsonColumnType) {
            for (const f of entity.fields.toArray()) {
                if (f.valueConverter.fieldTypeInDb === 'json') {
                    //@ts-ignore
                    f.valueConverter = {
                        ...f.valueConverter,
                        toDb: ValueConverters.JsonString.toDb,
                        fromDb: ValueConverters.JsonString.fromDb,
                    };
                }
            }
        }
        return new ActualSQLEntityDataProvider(entity, this, async (dbName) => {
            if (this.createdEntities.indexOf(dbName.$entityName) < 0) {
                this.createdEntities.push(dbName.$entityName);
                await this.sql.entityIsUsedForTheFirstTime(entity);
            }
        }, this.sql);
    }
    /**
     * Runs a transaction. Used internally by remult when transactions are required
     * @param action - The action to run in the transaction.
     * @returns The promise of the transaction.
     */
    transaction(action) {
        return this.sql.transaction(async (x) => {
            let completed = false;
            try {
                await action(new SqlDatabase({
                    createCommand: () => {
                        let c = x.createCommand();
                        return {
                            addParameterAndReturnSqlToken: (val) => {
                                return c.param(val);
                            },
                            param: (x) => c.param(x),
                            execute: async (sql) => {
                                if (completed)
                                    throw "can't run a command after the transaction was completed";
                                return c.execute(sql);
                            },
                        };
                    },
                    getLimitSqlSyntax: this.sql.getLimitSqlSyntax,
                    entityIsUsedForTheFirstTime: (y) => x.entityIsUsedForTheFirstTime(y),
                    transaction: (z) => x.transaction(z),
                    supportsJsonColumnType: this.sql.supportsJsonColumnType,
                    wrapIdentifier: this.wrapIdentifier,
                    end: this.end,
                    doesNotSupportReturningSyntax: this.sql.doesNotSupportReturningSyntax,
                    doesNotSupportReturningSyntaxOnlyForUpdate: this.sql.doesNotSupportReturningSyntaxOnlyForUpdate,
                    orderByNullsFirst: this.sql.orderByNullsFirst,
                }));
            }
            finally {
                completed = true;
            }
        });
    }
    /**
     * Creates a raw filter for entity filtering.
     * @param {CustomSqlFilterBuilderFunction} build - The custom SQL filter builder function.
     * @returns {EntityFilter<any>} - The entity filter with a custom SQL filter.
     * @example
     * SqlDatabase.rawFilter(({param}) =>
          `"customerId" in (select id from customers where city = ${param(customerCity)})`
        )
     * @see [Leveraging Database Capabilities with Raw SQL in Custom Filters](https://remult.dev/docs/custom-filter.html#leveraging-database-capabilities-with-raw-sql-in-custom-filters)
     */
    static rawFilter(build) {
        return {
            [customDatabaseFilterToken]: {
                buildSql: build,
            },
        };
    }
    /**
     *  Converts a filter to a raw SQL string.
     *  @see [Leveraging Database Capabilities with Raw SQL in Custom Filters](https://remult.dev/docs/running-sql-on-the-server#leveraging-entityfilter-for-sql-databases)
     
     */
    static async filterToRaw(repo, condition, sqlCommand, dbNames, wrapIdentifier) {
        if (!sqlCommand) {
            sqlCommand = new myDummySQLCommand();
        }
        const r = getRepository(repo);
        var b = new FilterConsumerBridgeToSqlRequest(sqlCommand, dbNames ||
            (await dbNamesOfWithForceSqlExpression(r.metadata, wrapIdentifier)));
        b._addWhere = false;
        await (await getRepositoryInternals(r)._translateWhereToFilter(condition)).__applyToConsumer(b);
        return await b.resolveWhere();
    }
    /**
     * `false` _(default)_ - No logging
     *
     * `true` - to log all queries to the console
     *
     * `oneLiner` - to log all queries to the console as one line
     *
     * a `function` - to log all queries to the console as a custom format
     * @example
     * SqlDatabase.LogToConsole = (duration, query, args) => { console.log("be crazy ;)") }
     */
    static LogToConsole = false;
    /**
     * Threshold in milliseconds for logging queries to the console.
     */
    static durationThreshold = 0;
    /**
     * Creates a new SQL database.
     * @param sql - The SQL implementation.
     * @example
     * const db = new SqlDatabase(new PostgresDataProvider(pgPool))
     */
    constructor(sql) {
        this.sql = sql;
        if (sql.wrapIdentifier)
            this.wrapIdentifier = (x) => sql.wrapIdentifier(x);
        if (isOfType(sql, 'provideMigrationBuilder')) {
            this.provideMigrationBuilder = (x) => sql.provideMigrationBuilder(x);
        }
        if (isOfType(sql, 'end'))
            this.end = () => sql.end();
    }
    provideMigrationBuilder;
    createdEntities = [];
    end;
}
const icons = new Map([
    // CRUD
    ['INSERT', 'âšª'],
    ['SELECT', 'ðŸ”µ'],
    ['UPDATE', 'ðŸŸ£'],
    ['DELETE', 'ðŸŸ¤'],
    // Additional
    ['CREATE', 'ðŸŸ©'],
    ['ALTER', 'ðŸŸ¨'],
    ['DROP', 'ðŸŸ¥'],
    ['TRUNCATE', 'â¬›'],
    ['GRANT', 'ðŸŸª'],
    ['REVOKE', 'ðŸŸ«'], // Used to take back permissions from a user.
]);
class LogSQLCommand {
    origin;
    logToConsole;
    constructor(origin, logToConsole) {
        this.origin = origin;
        this.logToConsole = logToConsole;
    }
    args = {};
    addParameterAndReturnSqlToken(val) {
        return this.param(val);
    }
    param(val, name) {
        let r = this.origin.param(val);
        this.args[r] = val;
        return r;
    }
    async execute(sql) {
        try {
            let start = new Date();
            let r = await this.origin.execute(sql);
            if (this.logToConsole !== false) {
                var d = new Date().valueOf() - start.valueOf();
                if (d > SqlDatabase.durationThreshold) {
                    const duration = d / 1000;
                    if (this.logToConsole === 'oneLiner') {
                        const rawSql = sql
                            .replace(/(\r\n|\n|\r|\t)/gm, ' ')
                            .replace(/  +/g, ' ')
                            .trim();
                        const first = rawSql.split(' ')[0].toUpperCase();
                        console.info(`${icons.get(first) || 'ðŸ’¢'} (${duration.toFixed(3)}) ${rawSql} ${JSON.stringify(this.args)}`);
                    }
                    else if (typeof this.logToConsole === 'function') {
                        this.logToConsole(duration, sql, this.args);
                    }
                    else {
                        console.info(sql + '\n', { arguments: this.args, duration });
                    }
                }
            }
            return r;
        }
        catch (err) {
            console.error((err.message || 'Sql Error') + ':\n', sql, {
                arguments: this.args,
                error: err,
            });
            throw err;
        }
    }
}
class ActualSQLEntityDataProvider {
    entity;
    sql;
    iAmUsed;
    strategy;
    static LogToConsole = false;
    constructor(entity, sql, iAmUsed, strategy) {
        this.entity = entity;
        this.sql = sql;
        this.iAmUsed = iAmUsed;
        this.strategy = strategy;
    }
    async init() {
        let dbNameProvider = await dbNamesOfWithForceSqlExpression(this.entity, (x) => this.sql.wrapIdentifier(x));
        await this.iAmUsed(dbNameProvider);
        return dbNameProvider;
    }
    async count(where) {
        let e = await this.init();
        let select = 'select count(*) count from ' + e.$entityName;
        let r = this.sql.createCommand();
        if (where) {
            let wc = new FilterConsumerBridgeToSqlRequest(r, e);
            where.__applyToConsumer(wc);
            select += await wc.resolveWhere();
        }
        return r.execute(select).then((r) => {
            return Number(r.rows[0].count);
        });
    }
    async find(options) {
        let e = await this.init();
        let { colKeys, select } = this.buildSelect(e);
        select = 'select ' + select;
        select += '\n from ' + e.$entityName;
        let r = this.sql.createCommand();
        if (options) {
            if (options.where) {
                let where = new FilterConsumerBridgeToSqlRequest(r, e);
                options.where.__applyToConsumer(where);
                select += await where.resolveWhere();
            }
            if (options.limit) {
                options.orderBy = Sort.createUniqueSort(this.entity, options.orderBy);
            }
            if (!options.orderBy) {
                options.orderBy = Sort.createUniqueSort(this.entity, new Sort());
            }
            if (options.orderBy) {
                let first = true;
                let segs = [];
                for (const s of options.orderBy.Segments) {
                    segs.push(s);
                }
                for (const c of segs) {
                    if (first) {
                        select += ' Order By ';
                        first = false;
                    }
                    else
                        select += ', ';
                    select += e.$dbNameOf(c.field);
                    if (c.isDescending)
                        select += ' desc';
                    if (this.sql._getSourceSql().orderByNullsFirst) {
                        if (c.isDescending)
                            select += ' nulls last';
                        else
                            select += ' nulls first';
                    }
                }
            }
            if (options.limit) {
                let page = 1;
                if (options.page)
                    page = options.page;
                if (page < 1)
                    page = 1;
                select +=
                    ' ' +
                        this.strategy.getLimitSqlSyntax(options.limit, (page - 1) * options.limit);
            }
        }
        return r.execute(select).then((r) => {
            return r.rows.map((y) => {
                return this.buildResultRow(colKeys, y, r);
            });
        });
    }
    buildResultRow(colKeys, y, r) {
        let result = {};
        for (let index = 0; index < colKeys.length; index++) {
            const col = colKeys[index];
            try {
                result[col.key] = col.valueConverter.fromDb(y[r.getColumnKeyInResultForIndexInSelect(index)]);
            }
            catch (err) {
                throw new Error('Failed to load from db:' + col.key + '\r\n' + err);
            }
        }
        return result;
    }
    buildSelect(e) {
        let select = '';
        let colKeys = [];
        for (const x of this.entity.fields) {
            if (x.isServerExpression) {
            }
            else {
                if (colKeys.length > 0)
                    select += ', ';
                select += e.$dbNameOf(x);
                if (x.options.sqlExpression)
                    select += ' as ' + x.key;
                colKeys.push(x);
            }
        }
        return { colKeys, select };
    }
    async update(id, data) {
        let e = await this.init();
        let r = this.sql.createCommand();
        let statement = 'update ' + e.$entityName + ' set ';
        let added = false;
        for (const x of this.entity.fields) {
            if (isDbReadonly(x, e)) {
            }
            else if (data[x.key] !== undefined) {
                let v = x.valueConverter.toDb(data[x.key]);
                if (v !== undefined) {
                    if (!added)
                        added = true;
                    else
                        statement += ', ';
                    statement += e.$dbNameOf(x) + ' = ' + r.param(v);
                }
            }
        }
        const idFilter = this.entity.idMetadata.getIdFilter(id);
        let f = new FilterConsumerBridgeToSqlRequest(r, e);
        Filter.fromEntityFilter(this.entity, idFilter).__applyToConsumer(f);
        statement += await f.resolveWhere();
        let { colKeys, select } = this.buildSelect(e);
        let returning = true;
        if (this.sql._getSourceSql().doesNotSupportReturningSyntax)
            returning = false;
        if (returning &&
            this.sql._getSourceSql().doesNotSupportReturningSyntaxOnlyForUpdate)
            returning = false;
        if (returning)
            statement += ' returning ' + select;
        return r.execute(statement).then((sqlResult) => {
            this.sql._getSourceSql().afterMutation?.();
            if (!returning) {
                return getRowAfterUpdate(this.entity, this, data, id, 'update');
            }
            if (sqlResult.rows.length != 1)
                throw new Error('Failed to update row with id ' +
                    id +
                    ', rows updated: ' +
                    sqlResult.rows.length);
            return this.buildResultRow(colKeys, sqlResult.rows[0], sqlResult);
        });
    }
    async delete(id) {
        let e = await this.init();
        let r = this.sql.createCommand();
        let f = new FilterConsumerBridgeToSqlRequest(r, e);
        Filter.fromEntityFilter(this.entity, this.entity.idMetadata.getIdFilter(id)).__applyToConsumer(f);
        let statement = 'delete from ' + e.$entityName;
        statement += await f.resolveWhere();
        return r.execute(statement).then(() => {
            this.sql._getSourceSql().afterMutation?.();
        });
    }
    async insert(data) {
        let e = await this.init();
        let r = this.sql.createCommand();
        let cols = '';
        let vals = '';
        let added = false;
        for (const x of this.entity.fields) {
            if (isDbReadonly(x, e)) {
            }
            else {
                let v = x.valueConverter.toDb(data[x.key]);
                if (v != undefined) {
                    if (!added)
                        added = true;
                    else {
                        cols += ', ';
                        vals += ', ';
                    }
                    cols += e.$dbNameOf(x);
                    vals += r.param(v);
                }
            }
        }
        let statement = `insert into ${e.$entityName} (${cols}) values (${vals})`;
        let { colKeys, select } = this.buildSelect(e);
        if (!this.sql._getSourceSql().doesNotSupportReturningSyntax)
            statement += ' returning ' + select;
        return await r.execute(statement).then((sql) => {
            this.sql._getSourceSql().afterMutation?.();
            if (this.sql._getSourceSql().doesNotSupportReturningSyntax) {
                if (isAutoIncrement(this.entity.idMetadata.field)) {
                    const id = sql.rows[0];
                    if (typeof id !== 'number')
                        throw new Error('Auto increment, for a database that is does not support returning syntax, should return an array with the single last added id. Instead it returned: ' +
                            JSON.stringify(id));
                    return this.find({
                        where: new Filter((x) => x.isEqualTo(this.entity.idMetadata.field, id)),
                    }).then((r) => r[0]);
                }
                else {
                    return getRowAfterUpdate(this.entity, this, data, undefined, 'insert');
                }
            }
            return this.buildResultRow(colKeys, sql.rows[0], sql);
        });
    }
}
class myDummySQLCommand {
    execute(sql) {
        throw new Error('Method not implemented.');
    }
    addParameterAndReturnSqlToken(val) {
        return this.param(val);
    }
    param(val) {
        if (val === null)
            return 'null';
        if (val instanceof Date)
            val = val.toISOString();
        if (typeof val == 'string') {
            if (val == undefined)
                val = '';
            return "'" + val.replace(/'/g, "''") + "'";
        }
        return val.toString();
    }
}
async function bulkInsert(array, db) {
    if (array.length == 0)
        return;
    const chunkSize = 250;
    for (let i = 0; i < array.length; i += chunkSize) {
        const items = array.slice(i, i + chunkSize);
        // do whatever
        const c = db.createCommand();
        let sql = 'insert into ' +
            (await items[0]._.metadata.dbName) +
            ' (' +
            (await Promise.all(items[0]._.metadata.fields.toArray().map((f) => f.dbName))).join(',') +
            ') values ';
        sql += items
            .map((row) => '(' +
            row.$.toArray()
                .map((f) => c.param(f.metadata.valueConverter.toDb(f.value)))
                .join(', ') +
            ')')
            .join(',');
        await c.execute(sql);
    }
}
export function getRowAfterUpdate(meta, dataProvider, data, id, operation) {
    const idFilter = id !== undefined ? meta.idMetadata.getIdFilter(id) : {};
    return dataProvider
        .find({
        where: new Filter((x) => {
            for (const field of meta.idMetadata.fields) {
                x.isEqualTo(field, data[field.key] ?? idFilter[field.key]);
            }
        }),
    })
        .then((r) => {
        if (r.length != 1)
            throw new Error(`Failed to ${operation} row - result contained ${r.length} rows`);
        return r[0];
    });
}
