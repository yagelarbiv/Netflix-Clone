import { doTransaction } from './context.js';
import { findOptionsToJson, liveQueryAction, } from './data-providers/rest-data-provider.js';
import { Filter, buildFilterFromRequestParameters, customUrlToken, } from './filter/filter-interfaces.js';
import { getRelationFieldInfo } from './remult3/relationInfoMember.js';
import { ForbiddenError } from './server-action.js';
export class DataApi {
    repository;
    remult;
    constructor(repository, remult) {
        this.repository = repository;
        this.remult = remult;
    }
    httpGet(res, req, serializeContext) {
        const action = req?.get('__action');
        if (action?.startsWith(liveQueryAction))
            return this.liveQuery(res, req, undefined, serializeContext, action.substring(liveQueryAction.length));
        switch (action) {
            case 'get':
            case 'count':
                return this.count(res, req, undefined);
        }
        return this.getArray(res, req, undefined);
    }
    async httpPost(res, req, body, serializeContext) {
        const action = req?.get('__action');
        function validateWhereInBody() {
            if (!body?.where) {
                throw {
                    message: `POST with action ${action} must have a where clause in the body`,
                    httpStatusCode: 400,
                };
            }
        }
        if (action?.startsWith(liveQueryAction)) {
            validateWhereInBody();
            return this.liveQuery(res, req, body, serializeContext, action.substring(liveQueryAction.length));
        }
        switch (action) {
            case 'get':
                validateWhereInBody();
                return this.getArray(res, req, body);
            case 'count':
                validateWhereInBody();
                return this.count(res, req, body);
            case 'deleteMany':
                validateWhereInBody();
                return this.deleteMany(res, req, body);
            case 'updateMany':
                validateWhereInBody();
                return this.updateManyImplementation(res, req, body);
            case 'endLiveQuery':
                await this.remult.liveQueryStorage.remove(body.id);
                res.success('ok');
                return;
            default:
                return this.post(res, body);
        }
    }
    static defaultGetLimit = 0;
    async get(response, id) {
        if (!this.repository.metadata.apiReadAllowed) {
            response.forbidden();
            return;
        }
        await this.doOnId(response, id, async (row) => response.success(this.repository.getEntityRef(row).toApiJson()));
    }
    async count(response, request, body) {
        if (!this.repository.metadata.apiReadAllowed) {
            response.forbidden();
            return;
        }
        try {
            response.success({
                count: +(await this.repository.count(await this.buildWhere(request, body))),
            });
        }
        catch (err) {
            response.error(err, this.repository.metadata);
        }
    }
    async deleteMany(response, request, body) {
        try {
            let deleted = 0;
            let where = await this.buildWhere(request, body);
            Filter.throwErrorIfFilterIsEmpty(where, 'deleteMany');
            return await doTransaction(this.remult, async () => {
                for await (const x of this.repository.query({
                    where,
                    include: this.includeNone(),
                })) {
                    await this.actualDelete(x);
                    deleted++;
                }
                response.success({ deleted });
            });
        }
        catch (err) {
            response.error(err, this.repository.metadata);
        }
    }
    async getArrayImpl(response, request, body) {
        let findOptions = {
            load: () => [],
            include: this.includeNone(),
        };
        findOptions.where = await this.buildWhere(request, body);
        if (request) {
            let sort = request.get('_sort');
            if (sort != undefined) {
                let dir = request.get('_order');
                findOptions.orderBy = determineSort(sort, dir);
            }
            let limit = +request.get('_limit');
            if (!limit && DataApi.defaultGetLimit)
                limit = DataApi.defaultGetLimit;
            findOptions.limit = limit;
            findOptions.page = +request.get('_page');
        }
        if (this.remult.isAllowed(this.repository.metadata.options.apiRequireId)) {
            let hasId = false;
            let w = await Filter.fromEntityFilter(this.repository.metadata, findOptions.where);
            if (w) {
                w.__applyToConsumer({
                    containsCaseInsensitive: () => { },
                    notContainsCaseInsensitive: () => { },
                    startsWithCaseInsensitive: () => { },
                    endsWithCaseInsensitive: () => { },
                    isDifferentFrom: () => { },
                    isEqualTo: (col, val) => {
                        if (this.repository.metadata.idMetadata.isIdField(col))
                            hasId = true;
                    },
                    custom: () => { },
                    databaseCustom: () => { },
                    isGreaterOrEqualTo: () => { },
                    isGreaterThan: () => { },
                    isIn: (col) => {
                        if (this.repository.metadata.idMetadata.isIdField(col))
                            hasId = true;
                    },
                    isLessOrEqualTo: () => { },
                    isLessThan: () => { },
                    isNotNull: () => { },
                    isNull: () => { },
                    not: () => { },
                    or: () => { },
                });
            }
            if (!hasId) {
                response.forbidden();
                throw new ForbiddenError();
            }
        }
        const r = await this.repository.find(findOptions).then(async (r) => {
            return await Promise.all(r.map(async (y) => this.repository.getEntityRef(y).toApiJson()));
        });
        return { r, findOptions };
    }
    includeNone() {
        let include = {};
        for (const field of this.repository.metadata.fields) {
            if (getRelationFieldInfo(field)) {
                include[field.key] = false;
            }
        }
        return include;
    }
    async getArray(response, request, body) {
        if (!this.repository.metadata.apiReadAllowed) {
            response.forbidden();
            return;
        }
        try {
            const { r } = await this.getArrayImpl(response, request, body);
            response.success(r);
        }
        catch (err) {
            if (err.isForbiddenError)
                response.forbidden();
            else
                response.error(err, this.repository.metadata);
        }
    }
    async liveQuery(response, request, body, serializeContext, queryChannel) {
        if (!this.repository.metadata.apiReadAllowed) {
            response.forbidden();
            return;
        }
        try {
            const r = await this.getArrayImpl(response, request, body);
            const data = {
                requestJson: await serializeContext(),
                findOptionsJson: findOptionsToJson(r.findOptions, this.repository.metadata),
                lastIds: r.r.map((y) => this.repository.metadata.idMetadata.getId(y)),
            };
            await this.remult.liveQueryStorage.add({
                entityKey: this.repository.metadata.key,
                id: queryChannel,
                data,
            });
            response.success(r.r);
        }
        catch (err) {
            if (err.isForbiddenError)
                response.forbidden();
            else
                response.error(err, this.repository.metadata);
        }
    }
    async buildWhere(request, body) {
        var where = [];
        if (this.repository.metadata.options.apiPrefilter) {
            if (typeof this.repository.metadata.options.apiPrefilter === 'function')
                where.push(await this.repository.metadata.options.apiPrefilter());
            else
                where.push(this.repository.metadata.options.apiPrefilter);
        }
        if (request) {
            let f = buildFilterFromRequestParameters(this.repository.metadata, {
                get: (key) => {
                    let result = body?.where?.[key];
                    if (result !== undefined)
                        return result;
                    result = request.get(key);
                    if (key.startsWith(customUrlToken) &&
                        result &&
                        typeof result === 'string')
                        return JSON.parse(result);
                    return result;
                },
            });
            if (this.repository.metadata.options.apiPreprocessFilter) {
                f = await this.repository.metadata.options.apiPreprocessFilter(f, {
                    metadata: this.repository.metadata,
                    getFilterPreciseValues: async (filter) => {
                        return Filter.getPreciseValues(this.repository.metadata, filter || f);
                    },
                });
            }
            where.push(f);
        }
        return { $and: where };
    }
    async doOnId(response, id, what) {
        try {
            var where = [
                this.repository.metadata.idMetadata.getIdFilter(id),
            ];
            if (this.repository.metadata.options.apiPrefilter) {
                if (typeof this.repository.metadata.options.apiPrefilter === 'function')
                    where.push(await this.repository.metadata.options.apiPrefilter());
                else
                    where.push(this.repository.metadata.options.apiPrefilter);
            }
            await this.repository
                .find({
                where: { $and: where },
                include: this.includeNone(),
            })
                .then(async (r) => {
                if (r.length == 0)
                    response.notFound();
                else if (r.length > 1)
                    response.error({
                        message: `id "${id}" is not unique for entity ` +
                            this.repository.metadata.key,
                    }, this.repository.metadata, 500);
                else
                    await what(r[0]);
            });
        }
        catch (err) {
            response.error(err, this.repository.metadata);
        }
    }
    async updateManyThroughPutRequest(response, request, body) {
        const action = request?.get('__action');
        if (action == 'emptyId') {
            return this.put(response, '', body);
        }
        return this.updateManyImplementation(response, request, {
            where: undefined,
            set: body,
        });
    }
    async updateManyImplementation(response, request, body) {
        try {
            let where = await this.buildWhere(request, body);
            Filter.throwErrorIfFilterIsEmpty(where, 'deleteMany');
            return await doTransaction(this.remult, async () => {
                let updated = 0;
                for await (const x of this.repository.query({
                    where,
                    include: this.includeNone(),
                })) {
                    await this.actualUpdate(x, body.set);
                    updated++;
                }
                response.success({ updated });
            });
        }
        catch (err) {
            response.error(err, this.repository.metadata);
        }
    }
    async actualUpdate(row, body) {
        let ref = this.repository.getEntityRef(row);
        await ref._updateEntityBasedOnApi(body);
        if (!ref.apiUpdateAllowed) {
            throw new ForbiddenError();
        }
        await ref.save();
        return ref;
    }
    async put(response, id, body) {
        await this.doOnId(response, id, async (row) => {
            const ref = await this.actualUpdate(row, body);
            response.success(ref.toApiJson());
        });
    }
    async actualDelete(row) {
        if (!this.repository.getEntityRef(row).apiDeleteAllowed) {
            throw new ForbiddenError();
        }
        await this.repository.getEntityRef(row).delete();
    }
    async delete(response, id) {
        await this.doOnId(response, id, async (row) => {
            await this.actualDelete(row);
            response.deleted();
        });
    }
    async post(response, body) {
        try {
            const insert = async (what) => {
                let newr = this.repository.create();
                await this.repository.getEntityRef(newr)._updateEntityBasedOnApi(what);
                if (!this.repository.getEntityRef(newr).apiInsertAllowed) {
                    throw new ForbiddenError();
                }
                await this.repository.getEntityRef(newr).save();
                return this.repository.getEntityRef(newr).toApiJson();
            };
            if (Array.isArray(body)) {
                const result = [];
                await doTransaction(this.remult, async () => {
                    for (const item of body) {
                        result.push(await insert(item));
                    }
                });
                response.created(result);
            }
            else
                response.created(await insert(body));
        }
        catch (err) {
            if (err.isForbiddenError)
                response.forbidden(err.message);
            else
                response.error(err, this.repository.metadata);
        }
    }
}
export function determineSort(sortUrlParm, dirUrlParam) {
    let dirItems = [];
    if (dirUrlParam)
        dirItems = dirUrlParam.split(',');
    let result = {};
    sortUrlParm.split(',').map((name, i) => {
        let key = name.trim();
        if (i < dirItems.length && dirItems[i].toLowerCase().trim().startsWith('d'))
            return (result[key] = 'desc');
        else
            return (result[key] = 'asc');
    });
    return result;
}
export function serializeError(data) {
    if (data instanceof TypeError) {
        data = { message: data.message, stack: data.stack };
    }
    let x = JSON.parse(JSON.stringify(data));
    if (!x.message && !x.modelState)
        data = { message: data.message, stack: data.stack };
    if (typeof x === 'string')
        data = { message: x };
    return data;
}
