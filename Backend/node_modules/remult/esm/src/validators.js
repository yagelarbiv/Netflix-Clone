export class Validators {
    static required = createValidator(async (_, e) => e.value != null && e.value != undefined && e.value !== '', 'Should not be empty');
    static unique = createValidator(async (_, e) => {
        if (!e.entityRef)
            throw 'unique validation may only work on columns that are attached to an entity';
        if (e.isBackend() && (e.isNew || e.valueChanged())) {
            return ((await e.entityRef.repository.count({
                [e.metadata.key]: e.value,
            })) == 0);
        }
        else
            return true;
    }, 'already exists');
    /**
     * @deprecated use `unique` instead - it also runs only on the backend
     */
    static uniqueOnBackend = createValidator(async (_, e) => {
        if (e.isBackend() && (e.isNew || e.valueChanged())) {
            return ((await e.entityRef.repository.count({
                [e.metadata.key]: e.value,
            })) == 0);
        }
        else
            return true;
    }, Validators.unique.defaultMessage);
    static regex = createValueValidatorWithArgs((val, regex) => regex.test(val));
    static email = createValueValidator((val) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(val), 'Invalid Email');
    static url = createValueValidator((val) => !!new URL(val), 'Invalid Url');
    static in = createValueValidatorWithArgs((val, values) => values.includes(val), (values) => `Value must be one of: ${values
        .map((y) => typeof y === 'object'
        ? y['id'] !== undefined
            ? y['id']
            : y.toString()
        : y)
        .join(', ')}`);
    static notNull = createValueValidator((val) => val != null, 'Should not be null');
    static enum = createValueValidatorWithArgs((value, enumObj) => Object.values(enumObj).includes(value), (enumObj) => `Value must be one of ${getEnumValues(enumObj).join(', ')}`);
    static relationExists = createValidator(async (_, e) => {
        if (e.valueIsNull())
            return true;
        if (!e.isBackend())
            return true;
        return Boolean(await e.load());
    }, 'Relation value does not exist');
    static maxLength = createValueValidatorWithArgs((val, maxLength) => val.length <= maxLength, (maxLength) => `Value must be at most ${maxLength} characters`);
    static minLength = createValueValidatorWithArgs((val, minLength) => val.length >= minLength, (maxLength) => `Value must be at least ${maxLength} characters`);
    static defaultMessage = 'Invalid value';
}
export function createValidator(validate, defaultMessage) {
    const validation = async (entity, e, message) => {
        const valid = await validate(entity, e);
        if (typeof valid === 'string' && valid.length > 0)
            e.error = valid;
        else if (!valid)
            e.error =
                (typeof message === 'function' && message(entity, e, undefined)) ||
                    message ||
                    (typeof defaultMessage === 'function' &&
                        defaultMessage(entity, e, undefined)) ||
                    defaultMessage ||
                    Validators.defaultMessage;
    };
    const result = (entityOrMessage, e, message) => {
        if (typeof entityOrMessage === 'string' ||
            entityOrMessage === 'function' ||
            (entityOrMessage === undefined && e === undefined)) {
            return async (entity, e, message) => await validation(entity, e, entityOrMessage || message);
        }
        return validation(entityOrMessage, e, message);
    };
    Object.defineProperty(result, 'defaultMessage', {
        get: () => {
            return defaultMessage;
        },
        set: (val) => {
            defaultMessage = val;
        },
        enumerable: true,
    });
    //@ts-ignore
    return Object.assign(result, {
        withMessage: (message) => async (entity, e) => result(entity, e, message),
    });
}
export function valueValidator(validate, defaultMessage) {
    return (entity, e) => validate(e.value) || defaultMessage || false;
}
export function createValueValidator(validate, defaultMessage) {
    return createValidator((_, e) => {
        if (e.value === undefined || e.value === null)
            return true;
        return validate(e.value);
    }, defaultMessage);
}
export function createValueValidatorWithArgs(validate, defaultMessage) {
    const result = createValidatorWithArgsInternal((_, e, args) => {
        if (e.value === undefined || e.value === null)
            return true;
        return validate(e.value, args);
    }, (_, e, args) => (typeof defaultMessage === 'function' && defaultMessage(args)) ||
        defaultMessage, true);
    return Object.assign((entity, e) => result(entity, e), {
        get defaultMessage() {
            return defaultMessage;
        },
        set defaultMessage(val) {
            defaultMessage = val;
        },
    });
}
export function createValidatorWithArgs(validate, defaultMessage) {
    return createValidatorWithArgsInternal(validate, defaultMessage);
}
function createValidatorWithArgsInternal(validate, defaultMessage, isValueValidator = false) {
    const result = (args, message) => async (entity, e) => {
        const valid = await validate(entity, e, args);
        if (typeof valid === 'string')
            e.error = valid;
        else if (!valid)
            e.error = message
                ? typeof message === 'function'
                    ? isValueValidator
                        ? message(args)
                        : message(entity, e, args)
                    : message
                : defaultMessage
                    ? typeof defaultMessage === 'function'
                        ? defaultMessage(entity, e, args)
                        : defaultMessage
                    : Validators.defaultMessage;
    };
    return Object.assign(result, {
        get defaultMessage() {
            return defaultMessage;
        },
        set defaultMessage(val) {
            defaultMessage = val;
        },
    });
}
export function getEnumValues(enumObj) {
    return Object.values(enumObj).filter((x) => typeof enumObj[x] !== 'number');
}
